# 1장. 데이터 타입

---

**학습목표**

- 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 알기
- 데이터 타입과 관련된 중요한 개념 살펴보기

# 1. 데이터 타입의 종류

## 기본형 타입

`Number` `String` `Boolean` `null` `undefined` `Symbol`

불변성을 가짐

→ 근데 a에 10을 할당한 후, 15를 다시 할당해도 되잖아? → 뒤에서 변하지 않는다는 의미를 공부하자

할당이나 연산 시 값이 담긴 주솟값을 바로 복제

## 참조형 타입

`Array` `Function` `Date` `RegExp` `Map, WeakMap` `Set, WeakSet`

값이 담긴 주솟값들로 이루어진 **묶음을 가리키는 주솟값**을 복제

불변성을 이해하기 위해,

메모리와 데이터에 대한 지식이 필요

`식별자` 와 `변수`의 개념을 구분할 수 있어야 함

# 2. 데이터 타입에 관한 배경지식

## 메모리와 데이터

바이트 단위의 탄생 배경

→ 고유한 식별자(unique identifier)인 비트를 8단위로 묶어 표현 가능한 값을 늘렸다

→ 모든 데이터는 `byte 단위의 식별자 (메모리 주솟값)`을 통해 서로 구분하고 연결할 수 있다

## 변수

변할 수 있는 무언가(데이터)

## 식별자

어떤 데이터를 식별하는데 사용하는 이름, 변수명

# 3. 변수 선언과 데이터 할당

- 데이터 영역
  → 할당될 **데이터**를 저장하기 위함
- 변수 영역
  → 할당될 **데이터의 주소값**을 저장하기 위함

## 변수 선언

```jsx
var a;
```

변할 수 있는 데이터를 만든다

이 데이터의 식별자는 a로 한다

컴퓨터는 메모리에 변수 영역의 비어있는 @1003 공간을 확보하고, 이름을 a라고 지정한다

## 데이터 할당

```jsx
a = 'abc';
```

`'abc'` 를 위의 @1003 공간의 값 자리에 직접 저장하지 않는다

1. 데이터 영역의 빈 공간(@5004)에 문자열 ‘abc’를 저장
2. 변수 영역에서 a라는 식별자를 검색(@1003)
3. 위에서 저장한 문자열의 주소(@5004)를 @1003공간에 값으로 저장

```jsx
a = 'abcdef';
```

기본 문자열에 어떤 변환을 가하든 상관 없이 무조건 새로 만들어 별도의 공간에 저장

1. 데이터 영역의 빈공간 @5005에 문자열 ‘abcedf’를 저장
2. 변수 영역에서 a라는 식별자 검색
3. ‘abcdef’ 문자열의 데이터 주소(@5005)를 @1003의 값으로 저장

> 5004 데이터를 참조하는 변수가 하나도 없으면 가비지 컬렉터 대상이 된다

## 변수 영역과 데이터 영역의 분리 이유

데이터 변환을 자유롭게 하고, 메모리를 효율적으로 관리하기 위해

JS는 숫자형 데이터에 8바이트 공간 할당하지만, 문자열 데이터에 정해진 공간 없음. 문자열 데이터는 필요한 메모리가 가변적이다

문자열 데이터의 변환을 효율적으로 처리하려면 변수와 데이터를 별도 공간에 나누어 저장하는 것이 최적이다

중복된 데이터에 대한 처리 효율이 높아진다

- 만약 미리 확보한 공간에서만 문자열 데이터 변환이 이루어진다면?
  → 확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업 필요하여 컴퓨터가 처리해야할 연산이 많아진다

# 4. 기본형 데이터와 참조형 데이터

## 불변값

변수와 상수를 구분 짓는 변경 가능성의 대상 : 변수 영역의 메모리

불변성 여부를 구분할 때의 변경 가능성의 대상 : 데이터 영역의 메모리

기본형 데이터는 모두 불변값

변수의 값이 변경되려면 데이터 영역에 값을 새로 만들어 그 값을 통해 변경이 이루어진다

데이터 영역에 한 번 만들어진 데이터 값은 가비지 컬렉팅 당하지 않는 이상 영원히 변하지 않는다

## 가변값

참조형 데이터의 기본적인 성질은 가변값

설정에 따라 변경 불가능한 경우도 있고, 아예 불변값으로 활용하는 방안도 있다

`Object.defineProperty` `Object.freeze`

## 참조형 데이터를 변수에 할당하는 과정

```jsx
var obj = {
  a: 1,
  b: 'bb',
};
```

1. 변수 영역에 빈 공간 @1002를 확보하고 이름을 obj로 저장한다
2. 데이터를 저장하기 위해, 데이터 영역의 빈공간 @5001을 확보한다
3. @5001에 데이터를 저장하려고 보니, 데이터가 여러 프로퍼티로 구성된 객체이다. 해당 객체의 프로퍼티의 값들을 저장하기 위해 별도의 변수 영역의 빈 공간 @7103~?을 확보하고 이 주소를 @5001의 값으로 저장한다
4. @7103에 a, @7104에 b라는 프로퍼티 이름을 저장한다
5. 데이터 영역에 1 검색이 안되니 @5003에 1을 저장하고 이 주소값을 @7103의 데이터 값으로 저장한다
6. 데이터 영역에 ‘bbb’ 검색이 안되니 @5004에 ‘bbb’을 저장하고 이 주소값을 @7104의 데이터 값으로 저장한다

객체의 변수(property) 영역이 별도로 존재

데이터 영역은 기존의 것을 그대로 사용한다

데이터 영역에 저장된 값은 모두 불변값 `@7013 ~ ?`

But, 객체의 변수 영역의 값은 가변. 그래서 참조형 데이터가 가변성을 가진다고 하는 것

```jsx
obj.a = 2;
```

1. 데이터 영역에서 2를 검색하고 없으니 빈 공간인 @5005에 데이터를 저장한다
2. 프로퍼티 a의 데이터 값을 @5005로 변경한다

obj의 데이터 값인 @5001은 변하지 않는다

## 가비지 컬렉터

각 변수는 `참조 카운트`를 가지는데, 이는 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 의미한다

참조 카운트가 0인 메모리 주소는 GC의 수거 대상이 된다

GC는 런타임 환경에 때라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거한다

수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다

## 변수 복사 비교

동작 원리를 알았으니, 기본형 데이터와 참조형 데이터의 차이를 알아보자

기본형과 참조형의 복사 과정은 동일하지만, 데이터 할당 과정에서 차이가 있기 때문에 변수 복사 이후의 동작에서 큰 차이가 발생한다

### 객체의 프로퍼티를 변경

```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'dd' };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

기본형 데이터를 복사한 b의 데이터 참조값은 변경

참조형 데이터를 복사한 obj2의 데이터 참조값은 변경되지 않음. 하지만, 객체의 프로퍼티 c가 참조하고 있는 데이터 참조값만 변경

### 객체 자체를 변경

```jsx
var a = 10;
var b = a;
var obj1 = { c: 10, d: 'dd' };
var obj2 = obj1;

b = 15;
obj2 = { c: 10, d: 'dd' };
```

이때는 새로운 값이 만들어진다

즉, 참조형 데이터가 ‘가변값’이라고 설명할 때의 ‘가변’은 참조형 데이터 자체를 변경할 경우가 아니라, 내부의 프로퍼티를 변경할 때 성립

**결론**
자바스크립트의 모든 데이터 타입은 참조형 데이터
기본형은 한 단계, 참조형은 두 단계에 걸쳐 일어날 뿐

# 5. 불변 객체

## 불변 객체

불변성을 성립하는 객체

내부 프로퍼티를 변경할 필요가 있을 때마다, 새로운 객체를 만들어 재할당

spread operator 혹은 라이브러리 사용

원본 객체가 변하지 않아야 하는 경우 필요함

## 얕은 복사

바로 아래 단계의 값만 복사

원본과 사본의 객체의 프로퍼티가 동일한 참조형 데이터의 주소를 가리킴

중첩된 객체를 얕은 복사 할때는 참조형 데이터가 저장된 프로퍼티를 복사할 때, 주솟값만 복사한다는 의미

```jsx
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};
```

## 깊은 복사

내부의 모든 값들을 하나하나 재귀적으로 찾아서 전부 복사

원본과 사본이 서로 완전히 다른 객체를 참조하여, 어느 쪽의 프로퍼티를 변경하더라도 영향을 주지 않음

```jsx
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === 'object' && target !== null) {
    // null도 Object
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    return target;
  }
  return result;
};
```

> `hasOwnProperty` 메서드를 활용해 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수 있다

> ES5의 getter/setter를 복사하는 방법은 ES6의 `Object.getOwnPropertyDescritor` 또는 ES2017의 `Object.getOwnPropertyDescriptors` 외에는 없다

## JSON 문법 활용한 깊은 복사

객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꿈

httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만을 다룰 때

```jsx
var copyObjectViaJSON = function (target) {
  return JSON.parse(JSON.stringfy(target));
};
```

메서드(함수)나 숨겨진 프로퍼티인 `__proto__` 나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시한다

# 6. undefined와 null

## undefined를 반환하는 경우

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때

```jsx
var a;
console.log(a); // undefined
```

> 위의 경우 자바스크립트가 직접 undefined를 할당
> var의 경우 변수가 생성되면서 undefined로 초기화
> let, const의 경우 변수가 생성될 때, undefined를 할당하지 않은 채로 초기화를 마친다. 해당 변수에 값이 할당되기 전까지는 해당 변수에 접근할 수 없다.

1. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때

```jsx
var obj = { a: 1 };
console.log(obj.b);  //-> (2)
console.log() *// referenceError: b is not defined*
```

1. return 문이 없거나 호출되지 않는 함수의 실행 결과

```jsx
var func = function () {};
var c = func(); // ->(3)
console.log(c); // undefined
```

## undefined와 배열

```jsx
var arr1 = new Array(3);
console.log(arr1); // *[empty x 3]*

var arr2 = [undefined, undefined, undefined];
console.log(arr2); // [undefined, undefined, undefined]
```

비어있는 요소(empty)는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다

```jsx
var arr1 = [undefined, 1]; // undefined를 할당
var arr2 = []; // 비어있는 요소
arr2[1] = 1;

// 메소드마다 다른 결과를 보임
arr1.forEach((v, i) => console.log(v, i)); // undefined 0 / 1 1
arr2.forEach((v, i) => console.log(v, i)); // 1 1

arr1.map((v, i) => v + i); // [NaN, 2]
arr2.map((v, i) => v + i); // [empty, 2]

arr1.filter((v) => !v); // [undefined]
arr2.filter((v) => !v); // []

arr1.reduce((p, c, i) => p + c + i, ''); // undefined011
arr2.reduce((p, c, i) => p + c + i, ''); // 11
```

존재하지 않는 프로퍼티(`empty`)에 대해서는 어떤 처리도 하지 않고 건너뛴다

값이 지정되지 않은 인덱스는 **아직 존재하지 않는 프로퍼티**

## undefined와 null

undefined가 반환되는 두 가지 경우

1. 사용자가 명시적으로 부여한 경우 → null로 명시하자. null의 존재 이유
2. 자바스크립트가 하는 수 없이 반환해주는 경우
   Q. 이때는 배열에서 empty를 반환하지 않음?

> typeof null은 Object
> null == undefined → true
> null === undefined → false
